# USAGE: 
#  $ ansible-playbook -e "rf=<IP1> sut=<IP2> runtime=120 interval=5 numpar=128" ./<file>.yml
#
# PLAYS:
#       Localhost: Parse and set cmdline vars
#       SUT: Start workload on SUT as async task, store cpuinfo vars
#       Localhost: Start power script as async task
#       SUT: sleep for 'runtime', poll async-Workload, save SUT-results
#       Localhost: Stop pwr script, write logfile, append SUT-results
#
# NOTE: jobfiles for both async tasks (SUT & localhost) are manually
#       cleaned up with use of 'async-status': mode 'cleanup'.
# SUT Server login credentials are set in PLAY 2 
# Redfish Server login credentials are set in PLAY 3 
############################################################################
---
# PLAY 1: Start with some housekeeping tasks
- hosts: localhost
  become: false
  gather_facts: false
  tasks:
    - name: Verify all req'd extra-vars are defined
      ansible.builtin.assert:
        that:
          - rf != ""
          - sut != ""
          - runtime != ""
          - interval != ""
          - numpar != ""

#    - name: Set runtime to int value for use in math ops
#      ansible.builtin.set_fact:
#         runtime_int: runtime | int

# Workaround to utilize 'sut' var as host
    - add_host:
        name: "{{ sut }}"

# PLAY 2: Start workload on SUT
# NOTE: this workload does not represent a fixed amount of compute work
#   SO not a good basis for normalizing results across varying cpu's
# Start workload on SUT (server under test) as async task
#- hosts: sut_host
- hosts: "{{ sut }}"
  remote_user: root
  become: false
  gather_facts: false
# Pad asynctime for Workload to ensure adequate wall clocktime
  vars:
    asynctime: "{{ (runtime * 2)|int|abs }}"
    ROOT_PASSWORD: 100yard-
  tasks:
    - name: set sut_host root password
      set_fact:
        ansible_password: "{{ ROOT_PASSWORD }}"

    - name: Record CPU Model
      shell: lscpu | awk '/^Model name:/{print $3}'
      register: cpumodel

    - name: Record number of CPU cores
      shell: lscpu | awk '/^CPU\(s\):/{print $2}'
      register: numcores

    - name: Record number of CPU sockets
      shell: lscpu | awk '/^Socket\(s\):/{print $2}'
      register: numsockets

    - name: Run Workload
#      Requires gather_facts to dynamically set {{ numpar }}
# Specify -bytes' to ensure runtime (only one is performed)
#      command: openssl speed -evp sha256 -bytes 16384 -seconds "{{ runtime }}" -multi "{{ numpar }}"
      shell: openssl speed -evp sha256 -bytes 16384 -seconds "{{ runtime }}" -multi "{{ numpar }}" 2>/dev/null | tail -1 | awk '{print $2}'
      async: "{{ asynctime }}"
      poll: 0
      register: workload

    - name: set sut_host vars from this PLAY for later use
      set_fact:
        cpu_model: "{{ cpumodel.stdout }}"
        num_cores: "{{ numcores.stdout }}"
        num_sockets: "{{ numsockets.stdout }}"

# PLAY 3: Start pwr monitoring script on localhost as async task
- hosts: localhost
  become: false
  gather_facts: false
# Pad asynctime to ensure adequate wall clocktime
  vars:
    ansible_python_interpreter: /usr/bin/python3
    asynctime: "{{ (runtime * 2)|int|abs }}"
    pwr_script: rfChassis.py
    rfSvr: "{{ rf }}"
    rfUser: "root"
    rfPasswd: "100yard-"
    outfile: "{{ numpar }}_test.log"

  tasks:
    - name: Start power monitoring script as async task
      shell: "./{{ pwr_script }} {{ rfSvr }} {{ rfUser }} {{ rfPasswd }} > {{ outfile }}"
      async: "{{ asynctime }}"
      poll: 0
      register: pwr_monitor
    
# Verify pwr_script is running before moving forward (pgrep)
    - name: Get power script PID
      command: "pgrep {{ pwr_script }}"
      register: pwr_pid

    - name: DEBUG
      ansible.builtin.debug:
        msg: "{{ pwr_script }} with PID {{ pwr_pid.stdout }} found"

    - name: set ansible_job_id from this PLAY for later Cleanup
      set_fact:
        pwrmon_jid: "{{ pwr_monitor.ansible_job_id }}"
        
###########
# PLAY 4: SUT wait for Workload (async) to complete
- hosts: "{{ sut }}"
  remote_user: root
  become: false
  gather_facts: false
  vars:
    ROOT_PASSWORD: 100yard-
  tasks:
    - name: Sleep 'runtime' to allow Workload to complete
      command: "sleep {{ runtime }}"
 
    - name: wait for Workload - async task
      ansible.builtin.async_status:
        jid: "{{ hostvars[sut].workload.ansible_job_id }}"
        mode: status
      register: async_job
      until: async_job.finished
      retries: 10
      delay: 1

#    - name: DEBUG
#      ansible.builtin.debug:
#              msg: "async_job contains: {{ async_job }}"

    - name: set Workload result sut_host var for later use
      set_fact:
        workload_stdout: "{{ async_job.stdout }}"

    - name: Workload cleanup - async task
      ansible.builtin.async_status:
        jid: "{{ hostvars[sut].workload.ansible_job_id }}"
        mode: cleanup

# PLAY 5: SUT Workload complete, kill pwr script and record results
- hosts: localhost
  become: false
  gather_facts: false
  vars:
    pwr_script: rfChassis.py
    outfile: "{{ numpar }}_test.log"
  tasks:
    - name: Kill power script PID with SIGINT
      command: "pkill -e -SIGINT {{ pwr_script }}"
      register: pkill_res
      
    - name: DEBUG
      ansible.builtin.debug:
        msg: "PKILL {{ pkill_res.stdout }}"

    - name: Sleep 2s to allow power script to complete writing logfile
      command: "sleep 2"
      
    - name: append cpuinfo and Workload rate to logfile
      ansible.builtin.blockinfile:
        path: "{{ outfile }}"
        create: no
        insertafter: EOF
        marker: "#{mark} SUT STATS"
        block: |
          "CPU-Model {{ hostvars[sut].cpu_model }}"
          "numcores {{ hostvars[sut].num_cores }}"
          "numsockets {{ hostvars[sut].num_sockets }}"
          "EVP Rate for -multi {{ numpar }} : {{ hostvars[sut].workload_stdout }}"
      
    - name: wrote pwr_script and SUT Workload output to logfile
      ansible.builtin.debug:
        msg: "Output written to file {{ outfile }}"

# CLEANUP async task manually: power_script (localhost)
    - name: wait for Workload and cleanup - async task
      ansible.builtin.async_status:
        jid: "{{ pwrmon_jid }}"
        mode: '{{ item }}'
      register: job
      until: job.finished or (job.erased is defined)
      retries: 5
      delay: 1
      loop:
        - 'status'
        - 'cleanup'

    - name: logfile written and CLEANUP complete
      ansible.builtin.debug:
        msg: "DONE"
